#!/usr/bin/env tsx
/**
 * Script to generate Zod schemas from OpenAPI/Swagger specification
 *
 * Usage:
 *   yarn generate-schemas
 *
 * This will:
 * 1. Fetch the latest OpenAPI spec from the backend
 * 2. Generate Zod schemas automatically with relaxed validation
 * 3. Update src/services/apis/schemas.ts
 */

import fs from 'fs/promises';
import path from 'path';
import {
  OPENAPI_URL,
  extractSchemasFromPaths,
  fetchOpenAPISpec,
  type OpenAPISchema,
} from './schemaUtils';

const OUTPUT_PATH =
  process.env.SCHEMA_OUTPUT_PATH || path.join(process.cwd(), 'src/services/apis/schemas.ts');

/**
 * Convert camelCase to snake_case to match actual API responses
 * The OpenAPI spec may have camelCase but the actual API returns snake_case
 */
function toSnakeCase(str: string): string {
  return str.replace(/[A-Z]/g, (letter) => `_${letter.toLowerCase()}`);
}

function convertToZod(schema: OpenAPISchema, name: string, required: boolean = true): string {
  if (!schema.type) {
    return 'z.unknown()';
  }

  let zodType = '';

  switch (schema.type) {
    case 'string':
      zodType = 'z.string()';
      break;
    case 'number':
    case 'integer':
      zodType = 'z.number()';
      break;
    case 'boolean':
      zodType = 'z.boolean()';
      break;
    case 'array':
      if (schema.items) {
        const itemType = convertToZod(schema.items, `${name}Item`, true);
        zodType = `z.array(${itemType})`;
      } else {
        zodType = 'z.array(z.unknown())';
      }
      break;
    case 'object':
      if (schema.properties && Object.keys(schema.properties).length > 0) {
        // Handle objects with defined properties
        const propsCode = Object.entries(schema.properties)
          .map(([propName, propSchema]) => {
            const propType = convertToZod(
              propSchema as OpenAPISchema,
              `${name}_${propName}`,
              false,
            );
            return `${propName}: ${propType}`;
          })
          .join(', ');
        zodType = `z.object({ ${propsCode} })`;
      } else if (schema.additionalProperties) {
        const valueType = convertToZod(schema.additionalProperties, `${name}Value`, true);
        zodType = `z.record(z.string(), ${valueType})`;
      } else {
        zodType = 'z.object({})';
      }
      break;
    default:
      zodType = 'z.unknown()';
  }

  // Make non-required fields optional with defaults for arrays
  if (!required) {
    if (schema.type === 'array') {
      zodType += '.optional().default([])';
    } else {
      zodType += '.optional()';
    }
  }

  return zodType;
}

async function generateSchemas() {
  console.log('üì• Fetching OpenAPI specification...');

  try {
    const spec = await fetchOpenAPISpec();
    console.log('‚úÖ OpenAPI spec fetched successfully\n');

    // Extract schemas from paths using shared utility
    const schemaInfos = extractSchemasFromPaths(spec);
    console.log(`üìä Found ${Object.keys(schemaInfos).length} schemas in OpenAPI spec`);
    console.log(`üìã Schema names: ${Object.keys(schemaInfos).join(', ')}\n`);

    let output = `/**
 * AUTO-GENERATED FILE - DO NOT EDIT MANUALLY
 *
 * This file is automatically generated from the OpenAPI specification.
 * To regenerate, run: yarn generate-schemas
 *
 * Source: ${OPENAPI_URL}
 * Generated: ${new Date().toISOString()}
 *
 * Note: Schemas are intentionally relaxed (optional fields, flexible types)
 * to handle real-world API responses gracefully.
 */

import { z } from 'zod';

`;

    // Generate schemas for each component
    let schemasGenerated = 0;
    for (const [schemaName, schemaInfo] of Object.entries(schemaInfos)) {
      console.log(`Processing: ${schemaName} (type: object)`);

      if (schemaInfo.properties && Object.keys(schemaInfo.properties).length > 0) {
        output += `// ${schemaName}\n`;
        output += `export const ${schemaName.charAt(0).toLowerCase() + schemaName.slice(1)}Schema = z.object({\n`;

        for (const [propName, propSchema] of Object.entries(schemaInfo.properties)) {
          // All fields are optional for relaxed validation
          const zodType = convertToZod(propSchema as OpenAPISchema, propName, false);
          // Convert to snake_case to match actual API responses
          const snakeCaseName = toSnakeCase(propName);
          output += `  ${snakeCaseName}: ${zodType},\n`;
        }

        output += `});\n\n`;
        output += `export type ${schemaName} = z.infer<typeof ${schemaName.charAt(0).toLowerCase() + schemaName.slice(1)}Schema>;\n\n`;
        schemasGenerated++;
      } else {
        console.log(`‚ö†Ô∏è  Skipping ${schemaName}: no properties found`);
      }
    }

    // Generate response wrapper schemas for list endpoints
    output += `// API Response Wrappers\n`;
    for (const schemaName of Object.keys(schemaInfos)) {
      const pluralName = schemaName.toLowerCase() + 's';
      output += `export const ${pluralName}ResponseSchema = z.object({\n`;
      output += `  data: z.array(${schemaName.charAt(0).toLowerCase() + schemaName.slice(1)}Schema),\n`;
      output += `});\n\n`;
      output += `export type ${schemaName}sResponse = z.infer<typeof ${pluralName}ResponseSchema>;\n\n`;
    }

    console.log(`\n‚úÖ Generated ${schemasGenerated} schemas\n`);

    await fs.writeFile(OUTPUT_PATH, output);

    console.log('‚úÖ Zod schemas generated successfully!');
    console.log(`üìù Output: ${OUTPUT_PATH}`);

    // Run Prettier to format the generated file
    console.log('‚ú® Formatting with Prettier...');
    const { execSync } = await import('child_process');
    try {
      execSync(`npx prettier --write ${OUTPUT_PATH}`, { stdio: 'inherit' });
      console.log('‚úÖ File formatted with Prettier\n');
    } catch (error) {
      console.warn('‚ö†Ô∏è  Prettier formatting failed, but file was generated\n');
    }

    console.log('‚ú® Schema generation complete!');
  } catch (error) {
    console.error('‚ùå Error generating schemas:', error);
    process.exit(1);
  }
}

generateSchemas();
